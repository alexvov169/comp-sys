<!DOCTYPE html>
<html lang="en">
<head>
<title>CS FIFO</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
* {
  box-sizing: border-box;
}

body {
  font-family: Arial, Helvetica, sans-serif;
}

.header {
  background-color: #f1f1f1;
  padding: 30px;
  text-align: center;
  font-size: 35px;
}

.task-idle,
.task-busy,
.task-active,
.row {
  display: -webkit-flex;
  display: flex;
  flex-wrap: wrap;
}

.button
.proc-busy,
.proc-active,
.column {
  -webkit-flex: 1;
  -ms-flex: 1;
  flex: 1;
}

    .check_b {
        text-align: center;
        width: 5%;
    }

.footer {
  background-color: #f1f1f1;
  padding: 10px;
  text-align: center;
}
.column1 {
    width: 25%;
    }

    #prob, #prob_text {
        font-size: 24px;
    }

.run,
.stop,
.button
.proc-busy,
.proc-active,
.task-busy,
.task-active,
.proc-idle,
.task-idle {
    margin: 10px;
    padding: 10px;
}

    .task-busy,
    .proc-busy {
        background-color: blue;
        box-shadow: 0 0 10px rgba(0, 0, 255, 1);
    }

    .task-active,
    .proc-active {
        background-color: #5ac955;
        box-shadow: 0 0 10px rgba(0, 255, 0, 1);
    }

    .task-idle,
    .proc-idle {
        background-color: #cccccc;
        box-shadow: 0 0 10px rgba(0, 0, 0, 1);
    }

    .task-wait {
        background-color: blue;
        box-shadow: 0 0 10px rgba(0, 0, 255, 1);
    }

    .inp {
        width: 60px;
    }

.run,
.stop,
.button {
  border: none;
  color: white;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  cursor: pointer;
}


    /*
    #task_procs {

        margin: 10px;
        padding: 10px;
        font-size: 14px;
        background-color: #cccccc;
        box-shadow: 0 0 10px rgba(0, 0, 0, 1);
    }*/

    .run {
        background-color: #5ac955;
        box-shadow: 0 0 10px rgba(0, 0, 0, 1);
    }
    .run:active {
        background-color: green;
        box-shadow: 0 0 10px rgba(0, 0, 0, 1) inset;
    }

    .stop {
        background-color: #f23030;
        box-shadow: 0 0 10px rgba(0, 0, 0, 1);
    }
    .stop:active {
        background-color: red;
        box-shadow: 0 0 10px rgba(0, 0, 0, 1) inset;
    }
    .run, .stop {
        margin-top: 30%;
    }

    .task_text {
        width: 70%;
    }

@media (max-width: 600px) {
  .row {
    -webkit-flex-direction: column;
    flex-direction: column;
  }
}
</style>
</head>
<body>

<div class="header">
  <h2>Планування задач в багатопроцесорних системах</h2>
</div>

<div class="column">
    <div class="row">
        <div class="button_columm"><button id="run" class="run">Run</button></div>
        <div class="button_columm"><button id="stop" class="stop">Stop</button></div>
        <div class="columm"><p id="prob_text">Імовірність появи задач <input id="prob" class="inp" type="number" name="power" value="0.1" min="0" max="1"></p></div>
        </div>
    </div>
<div class="row">
    <div class="column1" id="task-column"></div>
    <div class="column"><div class="row" id="proc-column"></div></div>
</div>
</div>

<div class="footer">
    <p></p>
</div>

<script>
        'use strict'
    
    var DOMWrapper = (function() {
        return function(wrapper_id) {
            var _element = document.getElementById(wrapper_id);
            return {
                get: () => _element,
                appendHTML: (html) => _element.insertAdjacentHTML('beforeend', html),
                getChildren: () => _element.children
            };
        };
    })();
    
    var MultipleElementsWrapper = (function() {
        return function(wrapper_id, html_creator) {
            var _root = DOMWrapper(wrapper_id);
            var _addNew = () => _root.appendHTML(html_creator());
            return {
                addNew: _addNew,
                getRoot: () => _root.get(),
                getAll: () => _root.getChildren(),
                createN: (n) => {
                    for (var i = 0; i < n; ++i) {
                        _addNew();
                    }
                }
            };
        };
    })();
    
    var MultipleElementsWrapperWithCounter = (function() {
        return function(wrapper_id, html_creator) {
            var _n = 0;
            var _root = MultipleElementsWrapper(wrapper_id, () => { 
                var html = html_creator(_n);
                ++_n;
                return html;
            });
            return {
                addNew: () => _root.addNew(),
                getRoot: () => _root.getRoot(),
                getAll: () => _root.getAll(),
                createN: (n) => _root.createN(n),
                getN: () => _n
            };
        };
    })();
    
    var ProcessorsWrapper = (function() {
        return function(wrapper_id) {
            var _html_creator = (_n) => {
                var proc_html 
                ='<div class="proc-idle">'
                    +'<div>Процесор №'+(_n+1)+'</div>'
                    +'<form>'
                        +'Потужність: '
                        +'<input class="inp" type="number" name="power" value="1" min="0"><br>'
                    +'</form><div>Вільний</div>'
                +'</div>';
                return proc_html;
            };
            var _root = MultipleElementsWrapperWithCounter(wrapper_id, _html_creator);
            var _getPower = (proc) => proc.children[1].children[0].value;
            function _fullPower() {
                var result = 0;
                for (var proc of _root.getAll()) {
                    result = (+result) + (+_getPower(proc));
                }
                return result;
            }
            return {
                getPower: _getPower,
                fullPower: _fullPower,
                getRoot: () => _root.getRoot(),
                getAll: () => _root.getAll(),
                create: (n) => _root.createN(n)
            };
        };
    })();
    
    var TasksWrapper = (function() {
        return function(wrapper_id, processors) {
            var _html_creator = (n) => {
                return '<div class="task-idle">'
                    +'<div class="">Задача №'+(n+1)+', Z('
                        +'<input class="inp" type="number" name="power" value="300" min="10" size="10">'
                    +')</div>'
                +'</div>';
            };
            var _root = MultipleElementsWrapperWithCounter(wrapper_id, _html_creator);
            var _n = 0;
            var _cbox_buf = [];
            function _getMatrix() {
                var matrix = [];
                for (var task of _root.getAll()) {
                    var c = 0;
                    var row = [];
                    for (var chb_w of task.children) {
                        if (c != 0) {
                            for (var chb of chb_w.children) {
                                if (chb.checked) {
                                    row.push(c);
                                }
                            }
                        }
                        ++c;
                    }
                    matrix.push(row);
                }
                return matrix;
            }
    
            function _initCheckBoxes(n) {
                _cbox_buf = _getMatrix();
            }
    
            function _randNum(min, max) {
                return Math.random() * (+max - +min) + +min;
            }
    
            function _randChBoxBuf() {
                var r = parseInt(_randNum(0, _cbox_buf.length-1));
                return r;
            }
            
            return {
                getMatrix: _getMatrix,
                initCheckBoxes: _initCheckBoxes,
                getComplexity: (task) => task.children[0].children[0].value,
                getRoot: () => _root.getRoot(),
                getAll: () => _root.getAll(),
                clearAll: () => {
                    //var r = _root.getRoot();
                    //r.innerHTML = '';
                    /*for (var t of _root.getAll()) {
                        t.remove();
                    }*/
                    /*while (r.children.length != 0) {
                        console.log('aaaaaaaa');
                        r.removeChild(r.firstChild);
                    }*/
                    //_n = 0;
                },
                initCheckBoxes: _initCheckBoxes,
                init: (n) => {
                    for (var i = 0; i < n; ++i) {
                        _root.getRoot().insertAdjacentHTML('beforeend', _html_creator(_n));
                        var curr = _root.getRoot().lastChild;
                        curr.num = _n;
                        for (var proc of processors.getAll()) {
                            curr.insertAdjacentHTML('beforeend', '<div class="column"><input type="checkbox" checked></div>');
                        }
                        ++_n;
                    }
                },
                create: (n) => {
                    for (var i = 0; i < n; ++i) {
                        _root.getRoot().insertAdjacentHTML('beforeend', _html_creator(_n));
                        var curr = _root.getRoot().lastChild;
                        
                        curr.num = _n;
                        
                        for (var proc of processors.getAll()) {
                            curr.insertAdjacentHTML('beforeend', '<div class="column"><input type="checkbox"></div>');
                        }
                        
                        var _chbox_row = _cbox_buf[_randChBoxBuf()];
                        //console.log(_chbox_row);
                        var c = 0;
                        var row_i = 0;
                        for (var chb of curr.children) {
                            if (c != 0) {
                                if (_chbox_row[row_i] == c) {
                                    chb.children[0].checked = true;
                                    ++row_i;
                                }
                            }
                            ++c;
                        }
                        ++_n;
                    }
                }
            };
        };
    })();
    
    var ParallelExecutionModel = (function() {
        return function(tasks_wrapper, procs_wrapper, display=true) {
            var full_power = 10 * 1000 * procs_wrapper.fullPower();
            var used_power = 0;
        
            function schedule() {
                var matrix = tasks_wrapper.getMatrix();
                var row_i = 0;
                for (var task of tasks_wrapper.getAll()) {
                    if (task.getAttribute('class') != 'task-active') {
                        var row = matrix[row_i];
                        if (row.length != 0) {
                            var col_i = 0;
                            var proc_i = 0;
                            var activated = false;
                            for (var proc of procs_wrapper.getAll()) {
                                if (row[col_i] == proc_i+1) {
                                    if (proc.getAttribute('class') != 'proc-active') {
                                        proc.setAttribute('class', 'proc-active');
                                        proc.lastChild.remove();
                                        proc.insertAdjacentHTML('beforeend', '<div>Обробка №'+(tasks.getAll()[row_i].num+1)+'</div>');
                                        task.setAttribute('class', 'task-active');
                                        tasks_wrapper.getAll()[row_i].proc = (row[col_i]);
                                        activated = true;
                                        break;
                                    }
                                    ++col_i;
                                }
                                ++proc_i;
                            }
                            if (!activated) break;
                        } else {
                            break;
                        }
                    }
                    ++row_i;
                }
            }
            function releaseProc(proc) {
                proc.setAttribute('class', 'proc-idle');
                proc.lastChild.remove();
                proc.insertAdjacentHTML('beforeend', '<div>Вільний</div>');
            }
            function removeFirstTask() {
                if (tasks_wrapper.getAll().length != 0) {
                    tasks_wrapper.getRoot().firstChild.remove();
                }
            }
            function releaseTaskProc(proc) {
                releaseProc(procs_wrapper.getAll()[proc-1]);
                schedule();
            }
            function makeParallelPromises() {
                schedule();
                var parallel_execution_promises = [];
                var i = 0;
                for (var task of tasks_wrapper.getAll()) {
                    if (task.getAttribute('class') != 'task-active') break;
                    var _proc = tasks_wrapper.getAll()[i].proc;
                    let complexity = tasks_wrapper.getComplexity(task);
                    let power = procs_wrapper.getPower(procs_wrapper.getAll()[_proc-1]);
                    var timeout = complexity / power;
                    parallel_execution_promises.push(new Promise(
                        (function(proc) { 
                            return function(resolve, reject) {
                                setTimeout(() => {
                                    used_power = (+used_power) + (+complexity);
                                    releaseTaskProc(proc);
                                    resolve();
                                }, timeout);
                            }; 
                        })(_proc)));
                    ++i;
                }
                return parallel_execution_promises;
            }
            
            async function runAll() {
                var task_probability = document.getElementById('prob').value;
                var work_finished = false;
    
                var work_time_secs = 10;
                (async() => setTimeout(() => {
                    work_finished = true;
                }, work_time_secs * 1000))();
    
                async function runScheduled() {
                    var parallel_execution_promises = makeParallelPromises();
                    for (var p of parallel_execution_promises) {
                        await p;
                        removeFirstTask();
                    };
                    return Promise.resolve();
                }
    
                async function runCurrentTasks() {
                    await runScheduled();
                    if (!work_finished) {
                        if (tasks_wrapper.getAll().length == 0) {
                            var added = false;
                            var interval = setInterval(async() => {
                                if (Math.random() < task_probability) {
                                    tasks_wrapper.create(1);
                                    added = true;
                                }
                                if (added) {
                                    clearInterval(interval);
                                    if (!work_finished) {
                                        await runCurrentTasks();
                                    }
                                }
                                //console.log(work_finished);
                            }, 1);
                        } else {
                            await runCurrentTasks();
                        }
                    } else {
                        return Promise.resolve();
                    }
                }
    
                (async() => setTimeout(function addTask() {
                    if (!work_finished) {
                        if (Math.random() < task_probability) {
                            tasks_wrapper.create(1);
                        }
                        setTimeout(addTask, 1);
                    }
                }, 1))();
    
                await runCurrentTasks();
            }
            async function _runTimes(n) {
                tasks_wrapper.initCheckBoxes();
                await runAll();
                tasks_wrapper.clearAll();
                for (var i = 1; i < n; ++i) {
                    tasks_wrapper.create(10);
                    await runAll();
                    tasks_wrapper.clearAll();
                }
                let average_used_power = used_power / n;
                alert('Використано потужності: '+used_power
                    +'\nСередня використана потужність: '+average_used_power
                    +'\nДоступно: '+full_power
                    +"\nККД = "+(100*average_used_power/full_power)
                    +"%\nККД' = "+(100*average_used_power/full_power)
                    +'%');
            }
            return {
                run: () => runAll(),
                runTimes: (n) => _runTimes(n)
            };
        };
    })();
        var tasks_id = 'task-column';
        var processors_id = 'proc-column';
        var processors = ProcessorsWrapper(processors_id);
        processors.create(5);
        var tasks = TasksWrapper(tasks_id, processors);
        tasks.init(10);
        var model = ParallelExecutionModel(tasks, processors);
        document.getElementById("run").addEventListener("click", () => {
            model.runTimes(1);
        });
    </script>

</body>
</html>
